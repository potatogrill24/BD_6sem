# ИНДЕКСЫ

### Для запуска файла ввести команду: 
```bash
docker exec -i store_db psql -U postgres -d store < tasks/indexes.sql
```

---

## Используемые типы индексов

### **B-tree** (по умолчанию)
- Работает по принципу бинарного дерева поиска.
- Эффективен для точного поиска (`=`, `>`, `<`, `BETWEEN`) и сортировки.
- Применим к большинству типов данных: даты, числа, строки.

### **GIN (Generalized Inverted Index)**
- Идеален для полнотекстового поиска, массивов, JSONB, и `LIKE`/`ILIKE` с `pg_trgm`.
- Создаёт индекс на вхождения подстрок (n-граммы), что позволяет быстро искать похожие слова.
- Поддерживает операторы `%`, `LIKE`, `SIMILARITY` при наличии `pg_trgm`/`pg_bigm`.

### **BRIN (Block Range Index)**
- Работает эффективно на **больших таблицах**, если значения **монотонно упорядочены** (например, даты или ID).
- Хранит диапазоны значений по блокам, а не сами значения.
- Занимает меньше памяти, но менее точен — требует фильтрации после обращения к блоку.

---

## Сравнение производительности запросов

**Запрос на выборку заказов (orders) по дате:**
- Без индекса: ~2431.7 мс
- С индексом (B-tree): ~1072.6 мс

**Запрос на выборку пользователей по email:**
- Без индекса: ~1050.6 мс
- С индексом (B-tree): ~0.05 мс

**Запрос на выборку пользователей по фамилии:**
- Без индекса: ~733.1 мс
- С индексом (GIN + trgm): ~281.7 мс

**Запрос по ключевому слову в комментариях:**
- Без индекса: ~2068.9 мс
- С индексом (GIN + trgm): ~172.1 мс

**Выборка товаров по order_id:**
- Без индекса: ~688.0 мс
- С индексом (BRIN): ~247.5 мс

**Поиск пользователей по дате регистрации:**
- Без индекса: ~460.7 мс
- С индексом (BRIN): ~454.1 мс (разница минимальна)

---

## Вывод
Индесы ускоряют поиск в БД, каждый тип эффективен по-своему, а именно:
- `B-tree` для точных фильтров (email, даты)
- `GIN` для текста и поиска по подстроке
- `BRIN` для больших таблиц с диапазонами (например, `order_id`, `registration_date`)

Выбор типа индекса зависит от характера запроса и размера таблицы.


# ТРАНЗАКЦИИ

### Запуск в двух сессиях:
```bash
# В одном терминале (Сессия A):
docker exec -it store_db psql -U postgres -d store

# Во втором терминале (Сессия B):
docker exec -it store_db psql -U postgres -d store
```
Далее нужно выполнять блоки кода из `transactions.sql` вручную по шагам.

---

## Уровни изоляции транзакций

| Уровень              | Видимость изменений | Защита от аномалий                             |
|----------------------|---------------------|-----------------------------------------------|
| **READ UNCOMMITTED** | Видит незакоммиченное | ❌ грязное чтение, ❌ неповторяющееся чтение, ❌ фантомы |
| **READ COMMITTED**   | Только коммиты других | ✅ грязное чтение, ❌ неповторяющееся, ❌ фантомы |
| **REPEATABLE READ**  | Один и тот же снимок | ✅ грязное, ✅ неповторяющееся, ❌ фантомы        |
| **SERIALIZABLE**     | Полная изоляция     | ✅ от всех типов аномалий                      |

---

## Аномалии транзакций

### 1. Грязное чтение (dirty read)
- **Описание:** Транзакция B читает данные, изменённые, но не зафиксированные транзакцией A.
- **Опасность:** Если A сделает ROLLBACK, B работала с несуществующими/откатными данными.

### 2. Неповторяющееся чтение (non-repeatable read)
- **Описание:** Транзакция A дважды читает одну и ту же строку, но между чтениями другая транзакция (B) изменила значение.
- **Результат:** A получает **разные значения** при одинаковом SELECT в рамках одной транзакции.

### 3. Фантомное чтение (phantom read)
- **Описание:** A делает SELECT по условию (например, COUNT), затем B добавляет строки, подходящие под это условие.
- **Результат:** Повторный SELECT A возвращает **новые строки**, которых не было в первом запросе.

---

## Вывод

- PostgreSQL по умолчанию использует `READ COMMITTED`, что **защищает от грязных чтений**, но **не от фантомов** и **неповторяющегося чтения**.
- Для строгой консистентности рекомендуется использовать `REPEATABLE READ` или `SERIALIZABLE`.


# РАСШИРЕНИЯ

### Для запуска файла ввести команду:
```bash
docker exec -i store_db psql -U postgres -d store < tasks/extensions.sql
```

---

## Расширение `pg_trgm`

**Описание:**
`pg_trgm` (trigram) разбивает строки на тройки символов и позволяет эффективно искать слова, которые **похожи по написанию**. Используется вместе с индексами `GIN` или `GiST`.

**Преимущества:**
- Позволяет делать нечеткий поиск по подстроке и орфографически похожим словам.
- Поддерживает операторы `%`, `SIMILARITY`, `ILIKE`, `LIKE`.
- Очень полезен в полях с отзывами, комментариями и ФИО.

**Недостатки:**
- Индекс может занимать значительный объём памяти на больших текстовых колонках.
- Сложнее интерпретировать результаты без `similarity()`.

---

## Расширение `pg_bigm`

**Описание:**
`pg_bigm` работает с биграммами — последовательностями из 2 символов. Позволяет ускорить **`LIKE '%...%'`-запросы**.

**Преимущества:**
- Более быстрое выполнение обычных подстрочных `LIKE`-запросов по сравнению с `pg_trgm`.
- Идеален для коротких и средних строк.
- Прост в использовании: создается GIN-индекс, аналогично `pg_trgm`.

**Недостатки:**
- Не поддерживает интеллектуальный поиск по похожим словам (только точные вхождения).
- Менее гибкий в настройке.

---

## Расширение `pgcrypto`

**Описание:**
Позволяет выполнять **симметричное и асимметричное шифрование** данных на уровне SQL. В проекте использовано `pgp_sym_encrypt()`/`decrypt()`.

**Преимущества:**
- Безопасное хранение конфиденциальной информации (email, пароли).
- Работает без внешних библиотек — прямо внутри PostgreSQL.
- Может применяться выборочно — только к чувствительным колонкам.

**Недостатки:**
- Шифрованные поля нельзя индексировать (по ним нельзя искать).
- Требуется защищённое хранилище ключей.
- Сложнее для интеграции в приложения, если нужно массовое дешифрование.
 users SET email_encrypted = pgp_sym_encrypt(email, 'secret_key');

---

## Вывод:
- `pg_trgm` — лучший выбор для умного поиска по тексту.
- `pg_bigm` — простой и быстрый вариант для LIKE-поисков.
- `pgcrypto` — мощное средство защиты, но требует аккуратной работы с ключами и компромисса по производительности.
